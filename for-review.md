Alright, let's cut straight to it. I've reviewed the rules you've set up (`auto-check`, `consistency`, `no-access-to-env`, `no-comments`, `project-structure-map`, `simplicity-effectiveness`, `styling`) and the configuration files (`app.json`, `babel.config.js`, `eas.json`, `global.css`, `metro.config.js`, `nativewind-env.d.ts`, `package.json`, `tailwind.config.js`, `tsconfig.json`).

You've got a decent foundation, particularly with the detailed `consistency` and `styling` rules. The project structure map is clear. However, relying solely on these isn't enough. You're setting yourself up for wasted time and frustrating errors if you assume any AI assistant will magically adhere to the *implicit* requirements buried in those config files or handle the nuances without explicit guardrails.

Here's the raw analysis of potential weak spots based on your setup:

1.  **The Supabase Metro Fragility:** Your `metro.config.js` has *critical* resolver overrides (`unstable_enablePackageExports: false`, specific `unstable_conditionNames`) specifically to make Supabase work with Expo's Metro bundler. This is non-standard and extremely easy for *any* developer, let alone an AI, to break by "helpfully" updating Metro config or dependencies without understanding this nuance. One wrong move here, and your Supabase integration goes dark.
2.  **State Management Complacency:** Your `consistency` rules mandate `useState`/`useContext` for the MVP. That's fine for simple cases, but it's a path that quickly leads to prop-drilling nightmares or unmanageable context spaghetti as complexity grows. An AI, aiming for "simplicity," might stick to this *too* rigidly or, conversely, introduce a complex state library prematurely without understanding *your* explicit (and currently simple) strategy. You need a rule that reinforces the *current* approach while acknowledging its limitations.
3.  **Sentry Logging Discipline:** You've set up Sentry and mandated a central `Logger` in your `consistency` rules. Good. But the risk is high that an AI will default to `console.log` or directly call Sentry methods, bypassing your abstraction, especially in Edge Functions (`_shared/logger.ts`) vs. the frontend (`utils/logger.ts`). This breaks your centralized logging/error reporting strategy.
4.  **NativeWind Theme Adherence:** You have a detailed `tailwind.config.js` and `styling` rules. Yet, the temptation to use arbitrary values (`mt-[7px]`, `text-[#ABCDEF]`) instead of theme-defined values (`mt-2`, `text-primary`) is constant. An AI needs explicit reinforcement to *always* prioritize theme values defined in `tailwind.config.js`.
5.  **API Abstraction Rigidity:** The `consistency` rule about abstracting API calls into `services/` is standard practice. However, an AI might place logic inappropriately (e.g., complex data transformation in a component instead of a service, or frontend logic leaking into an Edge Function).
6.  **Dependency Nuances:** You're using `react-native-sse` and `react-native-url-polyfill`. These aren't standard Expo libraries and point towards specific needs (Server-Sent Events, polyfilling web APIs). An AI might lack context on *why* these are needed or how to use them correctly within the Expo/React Native environment. Also, React 19/RN 0.79 are relatively new; an AI might not use the latest patterns or be aware of subtle breaking changes/best practices.

**Proposed New Cursor Rules:**

To mitigate these risks and keep AI agents focused, here are the rules you should add immediately. Don't create the files yet, just understand the *why*:

1.  **Filename:** `rule_metro-config-guard.md`
    *   **Description:** Explicitly forbid *any* modification to `metro.config.js`, especially the `resolver` section, without user confirmation. Must state that the current configuration is critical for Supabase compatibility and provide the specific lines that cannot be changed.
2.  **Filename:** `rule_state-management-mvp.md`
    *   **Description:** Reinforce the current MVP state management strategy (React `useState` for local, `useContext` for simple global state like auth). Forbid suggesting or implementing more complex state management libraries (Redux, Zustand, Jotai etc.) *during the MVP phase*. Explicitly state that Context should only be used for genuinely global data, not for avoiding prop-drilling in isolated feature areas.
3.  **Filename:** `rule_centralized-logging.md`
    *   **Description:** Mandate the *exclusive* use of the central `Logger` module (`utils/logger.ts` for frontend, `_shared/logger.ts` for backend). Explicitly forbid direct use of `console.log/warn/error` (except *within* the logger module itself) and direct calls to `Sentry.*` methods outside the logger. Require specifying the correct logger based on the environment (frontend/backend).
4.  **Filename:** `rule_nativewind-theme-priority.md`
    *   **Description:** Require *strict* adherence to using theme values defined in `tailwind.config.js` via NativeWind utility classes. Forbid the use of arbitrary/magic values in styling (e.g., `p-[13px]`, `text-[#123456]`). If a suitable theme value doesn't exist, the AI must ask the user if a new value should be added to the theme config.
5.  **Filename:** `rule_service-layer-boundary.md`
    *   **Description:** Reiterate that *all* external API interactions (Supabase DB, Auth, Edge Functions, Gemini) MUST go through functions defined in the `services/` directory (frontend) or be handled within dedicated Edge Functions (`supabase/functions/`). Forbid placing direct API calls or complex data fetching/mutation logic within UI components or hooks. Define clear boundaries for what logic belongs where (e.g., simple data formatting okay in components, business logic belongs in services/functions).

These rules aren't about micromanagement; they're about preventing predictable, time-wasting mistakes specific to *your* project's current setup and stated goals. Implement them to keep development focused and avoid getting sidetracked by avoidable technical debt or broken builds. 